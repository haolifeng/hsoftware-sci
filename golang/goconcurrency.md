# 并发

## goroutine

通过go关键字开启goroutine即可。goroutine是轻量级线程，goroutine的调动是由GOlang运行时进行管理的。
```
go 函数名(参数列表)
```
Go允许使用go语句开启一个新的运行期线程，即goroutine，以一个不同的、新创建的goroutine来执行一个函数。同一个程序中的所有goroutine共享一个地址空间，也就是可以访问相同的变量。
## 通道channel
### 定义
通道是用来传递数据的一个数据结构
通道可用于两个goroutine之间通过传递一个指定类型的值来同步运行和通讯。操作符<-用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。
注意，只有<-,没有其他的，比如“->,<->”等等。
### 创建
```
ch := make(chan int)
```
注意：默认情况下不带缓冲区的。发送端发送数据，同时必须有接收端相应的接收数据。

### 通道缓冲区
通道可以设置缓冲区，通过make的第二个参数指定缓冲区大小
```
ch := make(chain int, 100)
```
带缓冲区的通道允许发送端的数据和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。
注意：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。
## 遍历通道与关闭通道
Go通过range关键字来实现遍历读取到的数据，类似于与数据或切片。
通道使用close()函数来关闭。
##  并发模式

## goroutine和线程
### 动态栈
每一个OS线程都有一个固定大小的内存块（一般会是2MB)来做栈，这个栈会用了存储当前正在被调用或挂起（指在调用其他函数时）的函数的内部变量。这个固定大小的栈同时很大有很小。因为2MB的栈对于一个小小的goroutine来说是很大的内存浪费，比如对于我们用到的，一个只是用来WaitGroup之后关闭的channel的goroutine来说。对于go程序来说，同时创建成百上千个goroutine是非常普遍的，如果每一个goroutine都需要这么大的栈的话，那这么多的goroutine就不太可能了。除去大小的问题之外，固定大小的栈对于更复杂或者更深层次的递归函数调用来说显然是不够的。修改固定的大小可以提升空间的利用率允许创建更多的线程，而且可以允许更深的递归调用，不过这两者是没法同时兼备的。
相反，一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。一个goroutine的栈，和操作系统线程一样，会保存期活跃或挂起的函数调用本地变量，但是和OS线程不太一样的是一个goroutine的栈大小并不是固定的；栈的大小会根据需要动态的伸缩。而goroutine的栈的最大值有1GB，比传统的固定大小的线程栈要大得多，尽管一般情况下，大多goroutine都不需要这么大的栈。
### Goroutine调度
OS线程会被操作系统内核调度。每几毫秒，一个硬件计时器会中断处理器，这会调用一个叫做scheduler的内核函数。这个函数会挂起当前执行的线程并保存内存中它的寄存器内容，检查线程列表并决定下一次哪个线程可以被运行，并从内存中恢复该线程的寄存器信息。然后恢复执行该线程的现场并开始执行线程。因为操作系统线程是被内核所调度，所以从一个线程向另一个移动需要完整的上下文切换，也就是说，保存一个用户线程的状态到内存，恢复另一个线程的到寄存器，然后更新调度器的数据结构。这几步操作很慢，因为其局部性很差需要几次内存访问，并且会增加运行的CPU周期。  
Go的运行时包含了其自己的调度器，这个调度器使用了一些技术手段，比如M:N调度，因为其会在n高操作操作系统线程上多工（调度）m个goroutine。Go调度器的工作和内核的调度是相似的，但是这个调度器只关注单独的Go程序中的goroutine  
和操作系统的线程调度不同的是，Go调度器并不是一个硬件定时器而是被Go语言建筑本身进行调度的。例如当一个goroutine调用了time.Sleep或者被channel调用或者mutex操作阻塞时，调度器会使其进入休眠并开始执行另一个goroutine直到时机到了再去唤醒第一个goroutine。因为这种调度方式不需要进入内核的上下文，所以重新调度一个goroutine比调度一个线程代价要低得多。

### GOMAXPROCS
Go的调度器使用了一个叫做GOMAXPROCS的变量来决定会有多少个操作系统的线程同时执行GO的代码。其默认的值是运行机器上的CPU的核心数。

